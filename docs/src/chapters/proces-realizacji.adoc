== Proces realizacji

=== Model kaskadowy

W związku ze zbyt małą wiedzą członków zespołu na temat kryptowalut zdecydowano, aby pracę nad projektem rozpocząć w
modelu kaskadowym. Na początku, w celu zrozumienia tematu i poszerzenia swojej wiedzy każda z osób miała za zadanie
zapoznanie się z publikacjami odnośnie bitcoin <<btcbook>> oraz Lightning Network <<lnbook>>.
Kolejnym etapem było poszukiwanie bibliotek, które najlepiej pasowałyby do wymagań projektu. Przyjrzano się również
konkurencyjnym rozwiązaniom istniejącym już na rynku, aby upewnić się, że żadnego z nich nie można wykorzystać przy
implementacji aplikacji.
Finalnie, członkowie zespołu utwierdzili się w przekonaniu, że na rynku nie istnieje rozwiązanie spełniające w pełni
wymagania projektu oraz wyselekcjonowali biblioteki BitcoinJ i LightningJ, o których można dowiedzieć się więcej w
punkcie <<_uzyte_technologie,"Użyte technologie i biblioteki">>.
Aby zwizualizować to, jak powinna wyglądać aplikacja, zespół projektowy stworzył makietę interaktywną, która została
opisana w punkcie <<_makieta_interaktywna,"Makieta interaktywna">>.
Ostatnim krokiem, podjętym przed rozpoczęciem implementacji rozwiązania było stworzenie prototypu, który został
opisany w punkcie <<#_prototyp,"Prototyp">>.
Oprócz tego, zespół sporządził niezbędne dokumenty, takie jak: dokument założeń wstępnych czy też specyfikacja wymaga
systemowych.

Wszelkie pytania, niejasności, a także postęp prac były na bieżąco przedstawiane promotorowi- doktorowi Tadeuszowi
Puźniakowskiemu.
Dzięki podjętym krokom wyklarowała się finalna wizja aplikacji, dlatego zespół zdecydował o przejściu do metodyki
SCRUM i rozpoczęciu pracy w dwutygodniowych Sprintach.

=== Sprint 1

==== Cel

Głównym celem tego Sprintu było utworzenie projektów oraz konfiguracja środowisk, tak aby powstała niezbędna baza do
rozbudowy aplikacji.

==== Zadania

.Lista zadań w Sprincie 1
[cols="1,1,3,3,1,1"]
|===
|Klucz|Typ zadania|Nazwa|Osoba przypisana|Story points|Status

|LP-29|Zadanie|Set up java project|Aleksander Konieczny|3|Gotowe
|LP-30|Zadanie|Set up react project|Jan Pieczul|3|Gotowe
|LP-33|Zadanie|Set up mobile app project|Jan Pieczul|5|Gotowe
|LP-34|Spike|Research CI available options|Jan Pieczul|-|Gotowe
|LP-35|Zadanie|Create makefile for documents|Aleksander Konieczny|5|Gotowe
|LP-36|Zadanie|Create pipeline for Java webservice|Aleksander Konieczny|2|Gotowe
|LP-37|Zadanie|Create pipeline for React webapp|Jan Pieczul|3|Gotowe
|LP-38|Zadanie|Create pipeline for mobile app|Jan Pieczul|5|Gotowe
|LP-39|Zadanie|Pipeline for documents|Aleksander Konieczny|5|Gotowe
|LP-40|Zadanie|Add git hooks|-|3|Usunięte
|LP-41|Zadanie|Prepare docker-compose for lnd and bitcoind|Aleksander Konieczny|3|Gotowe
|LP-43|Zadanie|Migrate documents to asciidoc|Aleksander Konieczny|2|Gotowe
|LP-44|Zadanie|Configure container for PostgreSQL|Jan Pieczul|1|Gotowe
|===

==== Przebieg pracy

*Set up java project*
Celem tego zadania było utworzenie projektu w Springu, który korzysta z Javy 17. Jako narzędzie do budowania oraz
dodawania zależności wybrany został Maven. Dodane zostało również narzędzie do analizy formatowania kodu _checkstyle_
(Google Java Style).

*Set up react project*
Podczas tego zadania stworzony został projekt we frameworku React. Aby ułatwić pracę ze stylami dodano TailwindCSS. Do
analizy i formatowania kodu wybrane zostały narzędzia Eslint oraz Prettier. Za uruchamianie aplikacji odpowiada
natomiast narzędzie Vite.

*Set up mobile app project*
Projekt dla aplikacji mobilnej utworzony został we frameworku React-Native. Aby ułatwić budowanie i uruchamianie
aplikacji mobilnej użyto zestawu narzędzi Expo.

*Research CI available options*
Celem tego zadania było znalezienie rozwiązania CI/CD najlepiej pasującego do projektu. Zespół zdecydował się na
użycie Github.

*Create makefile for documents*
Członkowie zespołu uznali, że najlepszym rozwiązaniem będzie stworzenie całej dokumentacji w Asciidoc i przechowywanie
jej w głównym repozytorium projektu. Przy większej liczbie plików ich budowanie stawało się czasochłonne i niewygodne,
wiec pojawiła się potrzeba stworzenia _makefile_ do automatycznego budowanie wszystkich dokumentów. Dzięki temu
wystarczy tylko wywołać komendę _make_ w terminalu i każdy dokument zostaje zbudowany w formie pliku _html_ oraz _pdf_.

*Create pipeline for Java webservice*
W trakcie realizacji tego zadania stworzony został plik YAML dla Github Actions, który sprawdzał, czy projekt w Javie
poprawnie się buduje oraz uruchamia testy.

*Create pipeline for React webapp*
Dla projektu w React również został stworzony plik YAML dla Github Actions, który miał za zadanie uruchomić narzędzie
Eslint oraz zbudować pliki statyczne TypeScript.

*Create pipeline for mobile app*
Tak jak dla pozostałych dwóch projektów, dla aplikacji mobilnej również został stworzony plik YAML dla Github Actions,
który odpowiadał za uruchomienie Eslint.

*Pipeline for documents*
W tym zadaniu utworzony został plik dla Github Actions, który korzystając z komendy _grep_ sprawdzał, czy formatowanie
tekstu w dokumentach jest poprawne.

*Add git hooks*
Zadanie zostało stworzone, aby zabezpieczyć gałąź _master_ w repozytorium projektu przed wypychaniem niesprawdzonych
zmian oraz utrzymać porządek poprzez wymaganie kodu zadania w wiadomości przy wypychaniu zmian. W trakcie trwania
Sprintu zespół doszedł do wniosku, że zadanie nie ma sensu, ponieważ wypychane zmiany będą i tak _squashowane_, a
gałąź master może zostać zabezpieczona przez zmianę ustawień na platformie Github. W związku z tym zadanie zostało
uznane za zbędne i usunięte ze Sprintu.

*Prepare docker-compose for lnd and bitcoind*
Celem tego zadania było stworzenie pliku _docker-compose_ zawierającego niezbędne w aplikacji serwisy: _bitcoind_ oraz
_lnd_.
TODO (albo dopisać coś, albo kawałek kodu z YAMLa)

*Migrate documents to asciidoc*
Początkowo dokument założeń wstępnych oraz specyfikacja wymagań systemowych zostały stworzone z wykorzystaniem
oprogramowania _Microsoft Office Online_ co uniemożliwiało, śledzenie historii zmian w tychże plikach. Dlatego też
zdecydowano się na ich przeniesienie do formatu _AsciiDoc_. Dzięki temu zyskano możliwość nie tylko przeglądania
historii dokumentów, ale także łatwiejszą kontrolę/ wyłapywanie błędów po ich edycji.

*Configure container for PostgreSQL*
Aplikacja wymagała również bazy danych. Zespół zdecydował się na wybór _PostgreSQL_. Zadanie to polegało na
rozbudowaniu istniejącego już pliku _docker-compose.yaml_ i dodanie do niego tejże bazy danych.

==== Podsumowanie

Cel Sprintu został osiągnięty, ponieważ wszystkie zaplanowane zadania udało się ukończyć.
Wstępnie w Sprincie znalazło się 13 zadań wycenionych na 40 story pointów. Wykonanych zostało 12 z nich(1 zadanie
usunięte), co złożyło się na uzyskanie 37 story pointów na koniec pierwszej iteracji. Na poniższych wykresach można
zauważyć, jak prezentował się postęp prac w Sprincie 1.

.Wykres spalania sprintu(story pointy)
image::../images/sprints_raports/s_1/wykres_spalania_lz.png[]

=== Sprint 2

==== Cel

==== Zadania

==== Przebieg pracy

==== Testy??

=== Sprint 3

=== Sprint 4

=== Sprint 5

=== Sprint 6

=== Sprint 7

=== Sprint 8

=== Sprint 9

=== Sprint 10

=== Sprint 11
